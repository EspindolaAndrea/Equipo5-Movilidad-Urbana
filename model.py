# -*- coding: utf-8 -*-
"""it worked  !!!.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1AYr2LjDuJWz4CDexv75A4vrA-QbeA4-L
"""

# Commented out IPython magic to ensure Python compatibility.
# @title

# Jupyter code:
# !pip install mesa

# La clase `Model` se hace cargo de los atributos a nivel del modelo, maneja los agentes.
# Cada modelo puede contener múltiples agentes y todos ellos son instancias de la clase `Agent`.
from mesa import Agent, Model

# Debido a que necesitamos un solo agente por celda elegimos `SingleGrid` que fuerza un solo objeto por celda.
from mesa.space import MultiGrid

# Con `SimultaneousActivation` hacemos que todos los agentes se activen de manera simultanea.
from mesa.time import SimultaneousActivation

# Vamos a hacer uso de `DataCollector` para obtener el grid completo cada paso (o generación) y lo usaremos
# para graficarlo.
from mesa.datacollection import DataCollector

''' Jupyter code:
#para darle colorsito
from matplotlib.colors import ListedColormap


# %matplotlib inline
import matplotlib
import matplotlib.pyplot as plt
import matplotlib.animation as animation
plt.rcParams["animation.html"] = "jshtml"
#recibe abajo como parametro una cantidad de memoria en particular
matplotlib.rcParams['animation.embed_limit'] = 2**128
'''

# Definimos los siguientes paquetes para manejar valores númericos.
import numpy as np
import pandas as pd

# Definimos otros paquetes que vamos a usar para medir el tiempo de ejecución de nuestro algoritmo.
import time
import datetime

import networkx as nx

import random

# Definimos los siguientes paquetes para abrir un servidor y establecer la conexion con Unity
import socket
import json
import signal
import sys

# vamos a crear un array de tuplas que contengan las coordenadas




block_agent_perimeter = [(0,0),(0,1),(0,3),(0,5),(0,7),(0,9),(0,11),(0,13),(0,15),(0,17),(0,19),(0,21),(0,23),(24,0),(24,1),(24,3),(24,5),(24,7),(24,9),(24,11),(24,13),(24,15),(24,17),(24,19),(24,21),(24,23),
(2,0),(4,0),(6,0),(8,0),(10,0),(12,0),(14,0),(16,0),(18,0),(20,0),(22,0),(2,23),(4,23),(6,23),(8,23),(10,23),(12,23),(14,23),(16,23),(18,23),(20,23),(22,23)]


block_agent_inside_one = [(4,5),(4,6),(4,7),(4,8),(4,9),(5,7),(6,7),(7,7),(8,7),(9,7),(10,7),(11,7),(12,7),(13,7),(14,7),(15,7),(16,7),(17,7),(18,7),(19,7),(20,7),(20,5),(20,6),(20,7),(20,8),(20,9),(6,6),(8,6),(10,6),(12,6),(14,6),(16,6),(18,6),
(6,8),(8,8),(10,8),(12,8),(14,8),(16,8),(18,8)]


block_agent_inside_two = [(4,14),(4,15),(4,16),(4,17),(4,18),(5,16),(6,16),(7,16),(8,16),(9,16),(10,16),(11,16),(12,16),(13,16),(14,16),(15,16),(16,16),(17,16),(18,16),(19,16),(20,16),(20,14),(20,15),(20,16),(20,17),(20,18),(6,15),(8,15),(10,15),(12,15),(14,15),(16,15),(18,15),
(6,17),(8,17),(10,17),(12,17),(14,17),(16,17),(18,17)]


#park_coord = [(0,12), (23,0), (9,15), (13,23),(1,24)]

sum = block_agent_perimeter + block_agent_inside_one + block_agent_inside_two

park_coord = [(0,12), (9,15),(13,23),(13,17), (23,0)]



lista_1 = []
lista_2 = []
lista_3 = []
lista_4 = []
lista_5 = []
lista_6 = []
lista_7 = []

for i in range (25):
  lista_1.append((1,i))
  lista_2.append((i,12))
  lista_3.append((i,2))
  lista_4.append((23,i))
  lista_5.append((i,20))


for i in range (8,16):
  lista_6.append((9,i))

for i in range(17,24):
  lista_7.append((13,i))


G = nx.Graph()

for i in range(len(lista_1) - 1):
    G.add_edge(lista_1[i], lista_1[i + 1])


for i in range(len(lista_2) - 1):
    G.add_edge(lista_2[i], lista_2[i + 1])


for i in range(len(lista_3) - 1):
    G.add_edge(lista_3[i], lista_3[i + 1])


for i in range(len(lista_4) - 1):
    G.add_edge(lista_4[i], lista_4[i + 1])

for i in range(len(lista_5) - 1):
    G.add_edge(lista_5[i], lista_5[i + 1])


for i in range(len(lista_6) - 1):
    G.add_edge(lista_6[i], lista_6[i + 1])


for i in range(len(lista_7) - 1):
    G.add_edge(lista_7[i], lista_7[i + 1])



def get_grid(model):



    grid = np.zeros((model.grid.width, model.grid.height))

    global G

    g = list(G.nodes())

    for i in range (len(g)):
      x = g[i][0]
      y = g[i][1]

      grid[x][y] = 5



    #vamos a marcar siempre la salida para no tener la necesidad
    # de crear un agente

    grid[23][24] = 2
    grid[23][23] = 2
    grid[23][22] = 2
    grid[24][22] = 2
    grid[22][22] = 2



    for cell in model.grid.coord_iter():

        cell_content, cell_pos = cell

        if len(cell_content) != 0:

          #importante !!!!!!!!!!!!

          """
          agent = cell_content[0]  # Accede al primer agente en la lista
          print("cell content: ")
          print(agent)
          print(agent.dirt)

          """


          if hasattr(cell_content[0], 'car'):
            agent = cell_content[0]
            grid[cell_pos[0], cell_pos[1]] = agent.car


          if hasattr(cell_content[0], 'block'):
            agent = cell_content[0]
            grid[cell_pos[0], cell_pos[1]] = agent.block


          if hasattr(cell_content[0], 'park'):
            agent = cell_content[0]
            grid[cell_pos[0], cell_pos[1]] = agent.park


    return grid



class Car(Agent):

  def __init__(self, unique_id, model):
    super().__init__(unique_id, model)
    self.car = 4
    self.available = [True,True]
    self.directions = []


  def step(self):
    if(self.available[0] == False):
      if(self.pos != self.directions[-1]):
        next_index =  self.directions.index(self.pos) + 1
        next_step = self.directions[next_index]
        self.model.grid.move_agent(self, next_step)


class Park(Agent):
  def __init__(self, unique_id, model):
    super().__init__(unique_id, model)
    self.park = 3
    self.available = True
    self.flag = True


  def step(self):
    x,y = self.pos
    cell = model.grid.get_cell_list_contents((x, y))
    if len(cell) > 1:
      self.park = 4
    else:
      self.park = 3




class Block(Agent):

  def __init__(self, unique_id, model):
    super().__init__(unique_id, model)
    self.block = 1


  def step(self):
    pass


class ParkingLot(Model):

   def __init__(self,  C, B, P,   width, height):
        self.num_car =  C
        self.num_block = B
        self.num_park = P
        self.grid = MultiGrid(width, height, False)
        self.schedule = SimultaneousActivation(self)
        self.car_availability = []
        self.parking_spot_availability = []

        # Create agents
        for i in range(self.num_car):
            c = Car(i, self)
            self.schedule.add(c)


            x = 1
            y = 24


            self.grid.place_agent(c, (x, y))

            self.car_availability.append(c)


        #desde donde comienza el range siguiente para que las id no coincidan



        start = self.num_car + 1

        finish =  self.num_block + start

        iterador = 0

        for i in range( start , finish ):
            b = Block(i,self)
            self.schedule.add(b)

            x = sum[iterador][0]

            y = sum[iterador][1]

            iterador += 1

            self.grid.place_agent(b, (x,y))


        start = finish + 1

        finish = start + self.num_park

        iterador = 0

        for i in range( start , finish ):

          p = Park(i,self)
          self.schedule.add(p)

          x = park_coord[iterador][0]

          y = park_coord[iterador][1]

          iterador += 1

          self.grid.place_agent(p, (x,y))

          self.parking_spot_availability.append(p)



        self.datacollector = DataCollector(model_reporters={"Grid": get_grid}, agent_reporters={"Position": lambda a: a.pos, "Type": lambda a: type(a).__name__ }) # "AgentID": "unique_id"


   def cambiar_con_probabilidad(self,probabilidad):
    if random.random() < probabilidad:
        return not random.choice([True, False])
    else:
        return False

   def gamble_park(self):

    if self.cambiar_con_probabilidad(0.6):

      car_true_true = [obj for obj in self.car_availability if (obj.available[0] == True)]


      print(f"car_true_true: {car_true_true}")


      parking_space_true_true = [obj for obj in self.parking_spot_availability if obj.available == True]


      print(f" parking_space_true_true : {parking_space_true_true}")



      # checamos si hay objetos
      if car_true_true:
        if  parking_space_true_true:

          random_parking_space = random.choice(parking_space_true_true)
          random_car = random.choice(car_true_true)
          random_car.directions = nx.shortest_path(G, source= random_car.pos , target = random_parking_space.pos)
          random_car.available[0] = False
          random_car.available[1] = True
          random_parking_space.available  = False




   def step(self):
        self.gamble_park()
        self.datacollector.collect(self)
        self.schedule.step()



GRID_SIZE = 25

num_car = 5 #np.random.randint(5,10)

num_generaciones = 100

num_block = len(sum)

num_park = len(park_coord)

#print(f"num_car : { num_car}")

# Registramos el tiempo de inicio y corremos el modelo
start_time = time.time()
model = ParkingLot(num_car , num_block , num_park, GRID_SIZE, GRID_SIZE)
for i in range(num_generaciones):
    model.step()


# recojes los datos de los agentes
data = model.datacollector.get_agent_vars_dataframe().reset_index()

data_Car = data[data['Type'] == 'Car']

positions_Car = data_Car[["Step", "AgentID", "Position"]]


# Agrupamos el DataFrame por la columna 'Step'
grouped = positions_Car.groupby('Step')


def coord_matrix_maker( steps , cars, grouped ):

  matriz = np.empty((steps, cars), dtype=object)
  # Inicializar cada elemento con una tupla que contiene otra tupla y un booleano
  for i, grouped_data in grouped:
    iterador = 0
    for row in grouped_data.itertuples(index=True, name='Pandas'):
      agent_id = getattr(row, "AgentID")
      position = getattr(row, "Position")

      matriz[i, iterador] = (agent_id, position)
      iterador += 1
  return matriz



posiciones = coord_matrix_maker(num_generaciones, num_car, grouped)

print(posiciones)



# Imprimimos el tiempo que le tomó correr al modelo.
#print('Tiempo de ejecución:', str(datetime.timedelta(seconds=(time.time() - start_time))))


#all grid es un arreglo de matrices
all_grid = model.datacollector.get_model_vars_dataframe()


''' Jupyter code:
#%%capture

fig, axs = plt.subplots(figsize=(5,5))  #crea una figura de tamañp 5*5  , te hace una subfigura ( me imagino que son las celdas )

axs.set_xticks([])
axs.set_yticks([])



colors = [ (1, 1, 1),   # Blanco
          (0.5, 0.5, 0.5),  # gris
          (0.8, 0.0, 0.0),  # rojo cherry
          (0.4, 1.0, 0.4), # verde manzana
          (0, 0.4667, 1), # blue ribbon
           (1,1,0)]  # amarillo patito


cmap_custom = ListedColormap(colors)


patch = plt.imshow(all_grid.iloc[0][0], cmap=cmap_custom)


prev_lines = []

def animate(i):
    global prev_lines

    # Eliminar líneas de cuadrícula previas
    for line in prev_lines:
        line.remove()
    prev_lines.clear()

    # Actualiza los datos del grid
    patch.set_data(all_grid.iloc[i][0])

    # Agregar líneas de cuadrícula manualmente
    for x in range(GRID_SIZE + 1):
        for y in range(GRID_SIZE + 1):
            h_line, = axs.plot([-0.5, GRID_SIZE - 0.5], [y - 0.5, y - 0.5], color="gray", linestyle="--", linewidth=0.5)
            v_line, = axs.plot([x - 0.5, x - 0.5], [-0.5, GRID_SIZE - 0.5], color="gray", linestyle="--", linewidth=0.5)
            prev_lines.extend([h_line, v_line])

    # ... (tu código existente para dibujar contornos si aún lo necesitas)


anim = animation.FuncAnimation(fig, animate, frames=num_generaciones)


anim
'''

# Implementación libreria SOCKET

def handle_interrupt(sig, frame):
    print("\nServidor detenido.")
    server_socket.close()
    sys.exit(0)

signal.signal(signal.SIGINT, handle_interrupt)

# Configura el servidor
HOST = '127.0.0.1'  # Dirección IP del servidor (localhost en este ejemplo)
PORT = 8080       # Puerto en el que escuchará el servidor

# Crea un socket TCP/IP
server_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)

# Enlaza el socket al puerto
server_socket.bind((HOST, PORT))

# Escucha las conexiones entrantes
server_socket.listen()

print(f"Servidor escuchando en {HOST}:{PORT}")

while True:
    # Acepta una conexión entrante
    client_socket, addr = server_socket.accept()
    print(f"Conexión entrante desde {addr}")

    for i in range(num_generaciones):
        positions = []
        for j in range(num_car):
            car_id = str(j)
            position_data = posiciones[i][j]  # Obtiene la posición correspondiente a la generación actual
            x, y = position_data[1]  # Las coordenadas están en la posición 1 de la tupla
            z = 0.0

            car_data = {
                "car_id": car_id,
                "x": x,
                "y": y,
                "z": z
            }

            positions.append(car_data)

        # Crea un diccionario con el nombre de propiedad "positions"
        data = {"positions": positions}

        # Convierte el diccionario a formato JSON
        data_json = json.dumps(data)

        # Envía el JSON al cliente (Unity)
        client_socket.send(data_json.encode('utf-8'))

        # Espera un segundo antes de actualizar las posiciones nuevamente
        time.sleep(1)

    # Cierra la conexión
    client_socket.close()