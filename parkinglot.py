# -*- coding: utf-8 -*-
"""ParkingLot.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1BLyG_azFDgFUmw3NhgbE-hh1MzXJv47N
"""

# Commented out IPython magic to ensure Python compatibility.
# @title
!pip install mesa

# La clase `Model` se hace cargo de los atributos a nivel del modelo, maneja los agentes.
# Cada modelo puede contener múltiples agentes y todos ellos son instancias de la clase `Agent`.
from mesa import Agent, Model

# Debido a que necesitamos un solo agente por celda elegimos `SingleGrid` que fuerza un solo objeto por celda.
from mesa.space import MultiGrid

# Con `SimultaneousActivation` hacemos que todos los agentes se activen de manera simultanea.
from mesa.time import SimultaneousActivation

# Vamos a hacer uso de `DataCollector` para obtener el grid completo cada paso (o generación) y lo usaremos
# para graficarlo.
from mesa.datacollection import DataCollector


#para darle colorsito
from matplotlib.colors import ListedColormap


# %matplotlib inline
import matplotlib
import matplotlib.pyplot as plt
import matplotlib.animation as animation
plt.rcParams["animation.html"] = "jshtml"
#recibe abajo como parametro una cantidad de memoria en particular
matplotlib.rcParams['animation.embed_limit'] = 2**128

# Definimos los siguientes paquetes para manejar valores númericos.
import numpy as np
import pandas as pd

# Definimos otros paquetes que vamos a usar para medir el tiempo de ejecución de nuestro algoritmo.
import time
import datetime



# vamos a crear un array de tuplas que contengan las coordenadas




block_agent_perimeter = [(0,0),(0,1),(0,3),(0,5),(0,7),(0,9),(0,11),(0,13),(0,15),(0,17),(0,19),(0,21),(0,23),(24,0),(24,1),(24,3),(24,5),(24,7),(24,9),(24,11),(24,13),(24,15),(24,17),(24,19),(24,21),(24,23),
(2,0),(4,0),(6,0),(8,0),(10,0),(12,0),(14,0),(16,0),(18,0),(20,0),(22,0),(2,23),(4,23),(6,23),(8,23),(10,23),(12,23),(14,23),(16,23),(18,23),(20,23),(22,23)]


block_agent_inside_one = [(4,5),(4,6),(4,7),(4,8),(4,9),(5,7),(6,7),(7,7),(8,7),(9,7),(10,7),(11,7),(12,7),(13,7),(14,7),(15,7),(16,7),(17,7),(18,7),(19,7),(20,7),(20,5),(20,6),(20,7),(20,8),(20,9),(6,6),(8,6),(10,6),(12,6),(14,6),(16,6),(18,6),
(6,8),(8,8),(10,8),(12,8),(14,8),(16,8),(18,8)]


block_agent_inside_two = [(4,14),(4,15),(4,16),(4,17),(4,18),(5,16),(6,16),(7,16),(8,16),(9,16),(10,16),(11,16),(12,16),(13,16),(14,16),(15,16),(16,16),(17,16),(18,16),(19,16),(20,16),(20,14),(20,15),(20,16),(20,17),(20,18),(6,15),(8,15),(10,15),(12,15),(14,15),(16,15),(18,15),
(6,17),(8,17),(10,17),(12,17),(14,17),(16,17),(18,17)]

sum = block_agent_perimeter + block_agent_inside_one + block_agent_inside_two

def get_grid(model):
    grid = np.zeros((model.grid.width, model.grid.height))

    for cell in model.grid.coord_iter():

        cell_content, cell_pos = cell

        if len(cell_content) != 0:

          #importante !!!!!!!!!!!!

          """
          agent = cell_content[0]  # Accede al primer agente en la lista
          print("cell content: ")
          print(agent)
          print(agent.dirt)

          """


          if hasattr(cell_content[0], 'car'):
            agent = cell_content[0]
            grid[cell_pos[0], cell_pos[1]] = agent.car


          if hasattr(cell_content[0], 'block'):
            agent = cell_content[0]
            grid[cell_pos[0], cell_pos[1]] = agent.block


    return grid



class Car(Agent):

  def __init__(self, unique_id, model):
    super().__init__(unique_id, model)
    self.car = 2

    """

  def __del__(self):
    print(f"se ha limpiado la celda con posicion {self.pos}")

    """

  def step(self):
    pass




class Block(Agent):

  def __init__(self, unique_id, model):
    super().__init__(unique_id, model)
    self.block = 1


  def step(self):
    pass


class VacuumAgent(Agent):

  """

  def __init__(self, unique_id, model):
    super().__init__(unique_id, model)
    self.next_step = None
    self.here = 2
    self.cantidad_de_pasos = 0

  def move(self):
    neighbors = self.model.grid.get_neighborhood(
        self.pos,
        moore=True,
        include_center=False
        )

    print(neighbors)


        # Filtrar las posiciones que ya están ocupadas por agentes del mismo tipo.
    open_positions = [
        pos for pos in neighbors

        if not any(isinstance(agent, VacuumAgent) for agent in self.model.grid.get_cell_list_contents(pos))
        ]



    #print(f"open positions {open_positions}")

    #print(f"open positions type {type(open_positions)}")

    if open_positions:

      self.next_step = open_positions[( np.random.randint(len(open_positions)))]
      self.model.grid.move_agent(self, self.next_step)
      self.cantidad_de_pasos += 1
      # Si no hay posiciones abiertas, el agente no hace nada y se salta el paso.


  def limpiar(self):

    cellmates = self.model.grid.get_cell_list_contents([self.pos])
    for agent in cellmates:
      if type(agent) is DirtAgent:
        agent.dirt = 0
        del agent

    """


  def step(self):
    pass

    """
    self.move()
    self.limpiar()


    """


class ParkingLot(Model):

   def __init__(self,  C, B,  width, height):
        self.num_car =  C
        self.num_block = B
        self.grid = MultiGrid(width, height, False)
        self.schedule = SimultaneousActivation(self)

        # Create agents
        for i in range(self.num_car):
            c = Car(i, self)
            self.schedule.add(c)


            x = 1
            y = 24


            self.grid.place_agent(c, (x, y))


        #desde donde comienza el range siguiente para que las id no coincidan



        start = self.num_car + 1

        finish =  self.num_block + start

        iterador = 0

        for i in range( start , finish ):
            b = Block(i,self)
            self.schedule.add(b)

            x = sum[iterador][0]

            y = sum[iterador][1]

            iterador += 1

            print(f"x : {x}.  y: {y}.")

            self.grid.place_agent(b, (x,y))




        self.datacollector = DataCollector(model_reporters={"Grid": get_grid}, agent_reporters={"Position": lambda a: a.pos, "Type": lambda a: type(a).__name__})




   def step(self):
        self.datacollector.collect(self)
        self.schedule.step()



GRID_SIZE = 25

num_car = np.random.randint(5, 30)

num_generaciones = 1

num_block = len(sum)

print(f"num_car : { num_car}")

# Registramos el tiempo de inicio y corremos el modelo
start_time = time.time()
model = ParkingLot(num_car , num_block , GRID_SIZE, GRID_SIZE)
for i in range(num_generaciones):
    model.step()


# recojes los datos
data = model.datacollector.get_agent_vars_dataframe().reset_index()
data_Car = data[data['Type'] == 'Car']
positions_Car = data_Car["Position"]



print(f"estos son los datos de las posiciones : {positions_Car}")

print(f"que tipo de dato es posiciones : {type(positions_Car)}")


# Imprimimos el tiempo que le tomó correr al modelo.
print('Tiempo de ejecución:', str(datetime.timedelta(seconds=(time.time() - start_time))))


#all grid es un arreglo de matrices
all_grid = model.datacollector.get_model_vars_dataframe()



#%%capture

fig, axs = plt.subplots(figsize=(5,5))  #crea una figura de tamañp 5*5  , te hace una subfigura ( me imagino que son las celdas )

axs.set_xticks([])
axs.set_yticks([])



colors = [ (1, 1, 1),   # Blanco
          (0.5, 0.5, 0.5),  # Negro
          (0.8, 0.0, 0.0)]  # rojo cherry


cmap_custom = ListedColormap(colors)


patch = plt.imshow(all_grid.iloc[0][0], cmap=cmap_custom)


prev_lines = []

def animate(i):
    global prev_lines

    # Eliminar líneas de cuadrícula previas
    for line in prev_lines:
        line.remove()
    prev_lines.clear()

    # Actualiza los datos del grid
    patch.set_data(all_grid.iloc[i][0])

    # Agregar líneas de cuadrícula manualmente
    for x in range(GRID_SIZE + 1):
        for y in range(GRID_SIZE + 1):
            h_line, = axs.plot([-0.5, GRID_SIZE - 0.5], [y - 0.5, y - 0.5], color="gray", linestyle="--", linewidth=0.5)
            v_line, = axs.plot([x - 0.5, x - 0.5], [-0.5, GRID_SIZE - 0.5], color="gray", linestyle="--", linewidth=0.5)
            prev_lines.extend([h_line, v_line])

    # ... (tu código existente para dibujar contornos si aún lo necesitas)


anim = animation.FuncAnimation(fig, animate, frames=num_generaciones)


anim