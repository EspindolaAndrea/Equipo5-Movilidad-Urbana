# -*- coding: utf-8 -*-
"""Conexión.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1A8zN37ZDhbilcOYRkqqho2IHXr7yG4UO
"""

# Modelación de sistemas multiagentes con gráficas computacionales (Gpo 102)
# TC2008B.102

# EQUIPO 5:
# * Fernanda Elizabeth Romo Alarcon- A01639261
# * Jacobo Hirsch Rodríguez- A00829679
# * Andrea Alejandra Espíndola Gómez- A01639288
# * Jorge Carlos Mata Pacheco- A00829704


# BIBLIOTECAS NECESARIAS

# Manejar solicitudes HTTP, para poder hacer que el servidor responsa a los métodos GET, POST, etc.
# Crear el servidor simple y que maneje las solicitudes HTTP
from http.server import BaseHTTPRequestHandler, HTTPServer

# Para registrar los mensajes e estado y error, registrando info de las peticiones
import logging

# Se usa para transformar los datos de las posiciones de los boids en una cadena JSON que se envía a UNITY para su lectura.
import json

# Para las matrices multidimensionales
import numpy as np

# Clase personalizada Boid, proviniente de boid.py
# Se importa para crear instancias de boids y actualizar su estado y comportamiento en el espacio de simulación.
from boid import Boid

# INICIALIZAR VARIABLES GLOBALES DE ACUERDO CON LOS VALORES DEL CÓDIGO DE MESA

# Código del profe (REEMPLAZAR)
width = 30
height = 30
flock = [Boid(*np.random.rand(2)*30, width, height) for _ in range(20)]

# Funciones auxiliares

# Recorre cada  boid en flock, actualiza su comportamiento y posición,
#  y guarda las nuevas posiciones en la lista positions.
# Código del profe (REEMPLAZAR)
def updatePositions():
    global flock  # Se declara flock como variable global para modificar su estado
    positions = []  # Se inicializa una lista vacía para almacenar las nuevas posiciones
    for boid in flock:  # Se itera sobre cada boid en la lista flock
        boid.apply_behaviour(flock)  # Se aplica el comportamiento definido en la clase Boid
        boid.update()  # Se actualiza el estado del boid (posición, velocidad, etc.)
        pos = boid.edges()  # Se obtiene la nueva posición del boid, presumiblemente ajustada para los límites del espacio
        positions.append(pos)  # Se añade la nueva posición a la lista de posiciones
    return positions  # Se devuelve la lista completa de nuevas posiciones

# Convierte una lista de posiciones a un string JSON, que luego se puede enviar a Unity.

# Código del profe (REEMPLAZAR)
def positionsToJSON(ps):
    posDICT = []  # Se inicializa una lista vacía para almacenar los diccionarios de posiciones
    for p in ps:  # Se itera sobre cada posición en la lista de posiciones
        pos = {
            "x": p[0],  # Se asigna la primera componente de p a "x"
            "z": p[1],  # Se asigna la segunda componente de p a "z"
            "y": p[2]   # Se asigna la tercera componente de p a "y"
        }
        posDICT.append(pos)  # Se añade el diccionario a la lista
    return json.dumps(posDICT)  # Se convierte la lista de diccionarios a una cadena JSON y se devuelve

# Configura la respuesta HTTP con un código de estado 200 (éxito) y un tipo de contenido HTML.
# Código del profe (REEMPLAZAR si es necesario)

def _set_response(self):
    self.send_response(200)  # Envía un código de estado HTTP 200, que significa "Éxito"
    self.send_header('Content-type', 'text/html')  # Establece el tipo de contenido de la respuesta como "text/html"
    self.end_headers()  # Finaliza las cabeceras y prepara el cuerpo de la respuesta

#Esta es la parte crítica que interactuaría con Unity:
# Lee el cuerpo de la petición POST entrante.
# Llama a updatePositions() para actualizar las posiciones de los boids.
# Responde con las nuevas posiciones en formato JSON que Unity puede entender.
# Código del profe (REEMPLAZAR si es necesario)
def do_POST(self):
    content_length = int(self.headers['Content-Length'])  # Obtiene la longitud del contenido de la solicitud
    post_data = json.loads(self.rfile.read(content_length))  # Lee y deserializa el cuerpo de la solicitud
    logging.info("POST request,\nPath: %s\nHeaders:\n%s\n\nBody:\n%s\n",
                 str(self.path), str(self.headers), json.dumps(post_data))  # Loggea la información de la solicitud
    positions = updatePositions()  # Actualiza las posiciones de los boids
    self._set_response()  # Configura la respuesta HTTP
    resp = "{\"data\":" + positionsToJSON(positions) + "}"  # Crea el cuerpo de la respuesta
    self.wfile.write(resp.encode('utf-8'))  # Envía la respuesta

# Inicializa y arranca el servidor HTTP.

def run(server_class=HTTPServer, handler_class=Server, port=8585):
    logging.basicConfig(level=logging.INFO)
    server_address = ('', port)
    httpd = server_class(server_address, handler_class)
    logging.info("Starting httpd...\n") # HTTPD is HTTP Daemon!
    try:
        httpd.serve_forever()
    except KeyboardInterrupt:   # CTRL+C stops the server
        pass
    httpd.server_close()
    logging.info("Stopping httpd...\n")

# Este es el punto de entrada del script. Inicia la función run() que pone en marcha el servidor.
if __name__ == '__main__':
    from sys import argv
    if len(argv) == 2:
        run(port=int(argv[1]))
    else:
        run()